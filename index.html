<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Network Topology Mapper</title>
  <style>
    body {
      margin: 0;
      font-family: Inter, system-ui, sans-serif;
      background: #0f172a;
      color: #e5e7eb;
      overflow: hidden;
    }

    #toolbar {
      display: flex;
      gap: 8px;
      padding: 10px;
      background: #020617;
      border-bottom: 1px solid #1e293b;
    }

    button {
      background: #1e293b;
      border: none;
      color: #e5e7eb;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
    }

    button:hover {
      background: #334155;
    }

    #canvas {
      position: relative;
      width: 100vw;
      height: calc(100vh - 52px);
    }

    .device {
      position: absolute;
      width: 120px;
      background: #020617;
      border: 1px solid #334155;
      border-radius: 12px;
      padding: 10px;
      cursor: move;
      user-select: none;
    }

    .device h4 {
      margin: 0 0 6px;
      font-size: 14px;
      text-align: center;
    }

    .ports {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 4px;
    }

    .port {
      width: 14px;
      height: 14px;
      background: #1e293b;
      border-radius: 50%;
      cursor: pointer;
    }

    .port.used {
      background: #22c55e;
    }

    svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    polyline {
      fill: none;
      stroke: #38bdf8;
      stroke-width: 2;
    }
  </style>
</head>
<body>

<div id="toolbar">
  <button onclick="exportJSON()">Export JSON</button>
  <input type="file" id="importFile" accept="application/json" style="display:none" onchange="importJSON(event)" />
  <button onclick="document.getElementById('importFile').click()">Import JSON</button>
  <button onclick="deleteSelected()">Delete Selected</button>
  <button onclick="addDevice('Device', 1)">Add Device</button>
  <button onclick="addSwitch()">Add Switch</button>
  <button onclick="addPatchPanel()">Add Patch Panel</button>
  <button onclick="addAVDevice()">Add AV Equipment</button>
</div>

<div id="canvas">
  <svg id="links"></svg>
</div>

<script>
const canvas = document.getElementById('canvas');
const svg = document.getElementById('links');
let devices = [];
let connections = [];
let selectedDevice = null;
let selectedPort = null;
let tempLine = null;
let deviceIdCounter = 1;
const GRID = 20;

/* ---------- BASIC DEVICE ---------- */
function addDevice(type, fixedPorts = null) {
  let ports = fixedPorts ?? parseInt(prompt(`How many ports?`, '8'));
  if (!ports || ports < 1) return;

  createDevice(type, ports);
}

/* ---------- SWITCH (INPUT / OUTPUT) ---------- */
function addSwitch() {
  const inputs = parseInt(prompt('How many INPUT ports?', '8'));
  const outputs = parseInt(prompt('How many OUTPUT ports?', '8'));
  if (!inputs || !outputs) return;

  const device = createDevice('Switch', 0);

  addPorts(device, inputs, 'in', '#22c55e');
  addPorts(device, outputs, 'out', '#38bdf8');
}

/* ---------- AV DEVICE ---------- */
function addAVDevice() {
  const inputs = parseInt(prompt('How many INPUT ports?', '4'));
  const outputs = parseInt(prompt('How many OUTPUT ports?', '4'));
  if (!inputs || !outputs) return;

  const device = createDevice('AV Equipment', 0);

  addPorts(device, inputs, 'in', '#22c55e');
  addPorts(device, outputs, 'out', '#38bdf8');
}

/* ---------- PATCH PANEL ---------- */
function addPatchPanel() {
  const ports = parseInt(prompt('How many ports?', '24'));
  if (!ports) return;

  const device = createDevice('Patch Panel', 0);
  addPorts(device, ports, 'front', '#22c55e');
  addPorts(device, ports, 'rear', '#38bdf8');
}

/* ---------- DEVICE CREATION ---------- */
function createDevice(type, portCount) {
  const el = document.createElement('div');
  el.className = 'device';
  el.style.left = Math.random() * 600 + 'px';
  el.style.top = Math.random() * 300 + 'px';

  const title = document.createElement('h4');
  title.textContent = type;
  title.ondblclick = () => {
    const name = prompt('Rename device', title.textContent);
    if (name) title.textContent = name;
  };

  const portsEl = document.createElement('div');
  portsEl.className = 'ports';

  el.appendChild(title);
  el.appendChild(portsEl);
  canvas.appendChild(el);

  const device = { id: deviceIdCounter++, type, el, ports: [], portsEl };
  devices.push(device);

  if (portCount) addPorts(device, portCount);

  el.onclick = e => {
    e.stopPropagation();
    selectDevice(device);
  };

  makeDraggable(el);
  return device;
}

/* ---------- PORT CREATION ---------- */
function addPorts(device, count, direction = null, color = null) {
  for (let i = 0; i < count; i++) {
    const port = document.createElement('div');
    port.className = 'port';
    if (color) port.style.border = `2px solid ${color}`;
    port.title = direction ? `${direction.toUpperCase()} ${i + 1}` : `Port ${i + 1}`;
    port.onclick = () => handlePortClick(device, port);
    device.portsEl.appendChild(port);
    device.ports.push({ el: port, used: false, direction });
  }
}

/* ---------- CONNECTIONS ---------- */
function handlePortClick(device, portEl) {
  const port = device.ports.find(p => p.el === portEl);
  if (port.used) return;

  if (!selectedPort) {
    selectedPort = { device, port };
    portEl.style.outline = '2px solid #38bdf8';

    tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
    tempLine.setAttribute('stroke-dasharray', '4 4');
    svg.appendChild(tempLine);

    document.onmousemove = drawTempLine;
  } else {
    if (selectedPort.device === device) {
      cleanupTemp();
      alert('Cannot connect device to itself.');
      return;
    }
    connectPorts(selectedPort, { device, port });
    cleanupTemp();
  }
}

function connectPorts(a, b) {
  a.port.used = b.port.used = true;
  a.port.el.classList.add('used');
  b.port.el.classList.add('used');

  const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
  svg.appendChild(poly);

  connections.push({ a, b, poly });
  updateLines();
}

function drawTempLine(e) {
  if (!tempLine) return;

  const ra = selectedPort.port.el.getBoundingClientRect();
  const ca = canvas.getBoundingClientRect();

  const x1 = ra.left + ra.width / 2 - ca.left;
  const y1 = ra.top + ra.height / 2 - ca.top;
  const x2 = Math.round((e.clientX - ca.left) / GRID) * GRID;
  const y2 = Math.round((e.clientY - ca.top) / GRID) * GRID;
  const midX = Math.round((x1 + x2) / 2 / GRID) * GRID;

  tempLine.setAttribute('points', `${x1},${y1} ${midX},${y1} ${midX},${y2} ${x2},${y2}`);
}

function cleanupTemp() {
  if (tempLine) tempLine.remove();
  if (selectedPort) selectedPort.port.el.style.outline = '';
  tempLine = selectedPort = null;
  document.onmousemove = null;
}

/* ---------- DRAGGING ---------- */
function makeDraggable(el) {
  let ox, oy;
  el.onmousedown = e => {
    if (selectedPort) return;
    ox = e.offsetX;
    oy = e.offsetY;

    document.onmousemove = ev => {
      el.style.left = ev.pageX - ox + 'px';
      el.style.top = ev.pageY - oy + 'px';
      updateLines();
    };

    document.onmouseup = () => document.onmousemove = null;
  };
}

/* ---------- UTILITIES ---------- */
function updateLines() {
  connections.forEach(c => {
    const ra = c.a.port.el.getBoundingClientRect();
    const rb = c.b.port.el.getBoundingClientRect();
    const ca = canvas.getBoundingClientRect();

    const x1 = ra.left + ra.width / 2 - ca.left;
    const y1 = ra.top + ra.height / 2 - ca.top;
    const x2 = rb.left + rb.width / 2 - ca.left;
    const y2 = rb.top + rb.height / 2 - ca.top;
    const midX = Math.round((x1 + x2) / 2 / GRID) * GRID;

    c.poly.setAttribute('points', `${x1},${y1} ${midX},${y1} ${midX},${y2} ${x2},${y2}`);
  });
}

function selectDevice(device) {
  selectedDevice = device;
  devices.forEach(d => d.el.style.outline = '');
  if (device) device.el.style.outline = '2px solid #38bdf8';
}

function deleteSelected() {
  if (!selectedDevice) return;
  connections = connections.filter(c => {
    if (c.a.device === selectedDevice || c.b.device === selectedDevice) {
      c.poly.remove();
      return false;
    }
    return true;
  });
  selectedDevice.el.remove();
  devices = devices.filter(d => d !== selectedDevice);
  selectedDevice = null;
}

/* ---------- EXPORT / IMPORT ---------- */
function exportJSON() {
  const data = {
    devices: devices.map(d => ({
      id: d.id,
      type: d.type,
      name: d.el.querySelector('h4').textContent,
      x: parseInt(d.el.style.left),
      y: parseInt(d.el.style.top),
      ports: d.ports.length
    })),
    connections: connections.map(c => ({
      a: { deviceId: c.a.device.id, portIndex: c.a.device.ports.indexOf(c.a.port) },
      b: { deviceId: c.b.device.id, portIndex: c.b.device.ports.indexOf(c.b.port) }
    }))
  };

  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'topology.json';
  link.click();
}

function importJSON(event) {
  const reader = new FileReader();
  reader.onload = e => location.reload() || loadFromData(JSON.parse(e.target.result));
  reader.readAsText(event.target.files[0]);
}
</script>

</body>
</html>
